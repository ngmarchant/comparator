% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Measure.R, R/CppMeasure.R, R/NumericMeasure.R,
%   R/Chebyshev.R, R/InVocabulary.R, R/Lookup.R, R/MongeElkan.R
\name{elementwise}
\alias{elementwise}
\alias{elementwise,CppMeasure,vector,vector-method}
\alias{elementwise,NumericMeasure,matrix,vector-method}
\alias{elementwise,NumericMeasure,vector,matrix-method}
\alias{elementwise,NumericMeasure,vector,vector-method}
\alias{elementwise,Chebyshev,matrix,matrix-method}
\alias{elementwise,InVocabulary,vector,vector-method}
\alias{elementwise,Lookup,vector,vector-method}
\alias{elementwise,MongeElkan,vector,vector-method}
\title{Elementwise Similarity/Distance Vector}
\usage{
elementwise(measure, x, y, ...)

\S4method{elementwise}{CppMeasure,vector,vector}(measure, x, y, ...)

\S4method{elementwise}{NumericMeasure,matrix,vector}(measure, x, y, ...)

\S4method{elementwise}{NumericMeasure,vector,matrix}(measure, x, y, ...)

\S4method{elementwise}{NumericMeasure,vector,vector}(measure, x, y, ...)

\S4method{elementwise}{Chebyshev,matrix,matrix}(measure, x, y, ...)

\S4method{elementwise}{InVocabulary,vector,vector}(measure, x, y, ...)

\S4method{elementwise}{Lookup,vector,vector}(measure, x, y, ...)

\S4method{elementwise}{MongeElkan,vector,vector}(measure, x, y, ...)
}
\arguments{
\item{measure}{a measure used to compare the objects, which is a sub-class
of \code{\linkS4class{Measure}}.}

\item{x, y}{a collection of objects to compare, typically stored as entries
in an atomic vector, rows in a matrix, or entries in a list. The required
format depends on the type of \code{measure}. If \code{x} and \code{y} do not contain
the same number of objects, the smaller collection is recycled according
to standard \code{R} behavior.}

\item{...}{other parameters passed on to other methods.}
}
\value{
Every object in \code{x} is compared to every object in \code{y} elementwise
(with recycling) using the given measure , to produce a numeric vector of
scores of length \eqn{max{size(x), size(y)}}.
}
\description{
Computes elementwise similarities/distances between two collections of
objects (strings, vectors, etc.) using the provided measure.
}
\section{Methods (by class)}{
\itemize{
\item \code{measure = CppMeasure,x = vector,y = vector}: Specialization for \code{\linkS4class{CppMeasure}} where \code{x}
and \code{y} are vectors of strings to compare.

\item \code{measure = NumericMeasure,x = matrix,y = vector}: Specialization for \code{\link{NumericMeasure}} where \code{x} is a
matrix of rows (interpreted as vectors) to compare with a vector \code{y}.

\item \code{measure = NumericMeasure,x = vector,y = matrix}: Specialization for \code{\link{NumericMeasure}} where \code{x} is a
vector to compare with a matrix \code{y} of rows (interpreted as vectors).

\item \code{measure = NumericMeasure,x = vector,y = vector}: Specialization for \code{\link{NumericMeasure}} where \code{x} and \code{y}
are vectors to compare.

\item \code{measure = Chebyshev,x = matrix,y = matrix}: Specialization for \code{\link{Chebyshev}} where \code{x} and \code{y}
matrices of rows (interpreted as vectors) to compare. If \code{x} any \code{y} do
not have the same number of rows, rows are recycled in the smaller matrix.

\item \code{measure = InVocabulary,x = vector,y = vector}: Specialization for \code{\link{InVocabulary}} where \code{x} and
\code{y} are vectors of strings to compare.

\item \code{measure = Lookup,x = vector,y = vector}: Specialization for a \code{\link{Lookup}} where \code{x} and \code{y}
are vectors of strings to compare

\item \code{measure = MongeElkan,x = vector,y = vector}: Specialization for \code{\link{MongeElkan}} where \code{x} and \code{y}
are vectors of strings to compare.
}}

\note{
This function is not strictly necessary, as the \code{measure} itself is a
function that returns elementwise vectors of scores. In other words,
\code{measure(x, y)} is equivalent to \code{elementwise(measure, x, y)}.
}
\examples{
## Compute the absolute difference between two sets of scalar observations
data("iris")
x <- as.matrix(iris$Sepal.Width)
y <- as.matrix(iris$Sepal.Length)
elementwise(Euclidean(), x, y)

## Compute the edit distance between columns of two linked data.frames
col.1 <- c("Hasna Yuhanna", "Korina Zenovia", "Phyllis Haywood", "Nicky Ellen")
col.2 <- c("Hasna Yuhanna", "Corinna Zenovia", "Phyllis Dorothy Haywood", "Nicole Ellen")
elementwise(Levenshtein(), col.1, col.2)
Levenshtein()(col.1, col.2)               # equivalent to above

## Recycling is used if the two collections don't contain the same number of objects
elementwise(Levenshtein(), "Cora Zenovia", col.1)

}
