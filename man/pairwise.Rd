% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Measure.R, R/CppMeasure.R, R/StringMeasure.R,
%   R/NumericMeasure.R, R/Chebyshev.R, R/Minkowski.R, R/InVocabulary.R,
%   R/Lookup.R, R/MongeElkan.R
\name{pairwise}
\alias{pairwise}
\alias{pairwise,Measure,ANY,missing-method}
\alias{pairwise,CppMeasure,vector,vector-method}
\alias{pairwise,CppMeasure,vector,NULL-method}
\alias{pairwise,StringMeasure,vector,vector-method}
\alias{pairwise,NumericMeasure,matrix,vector-method}
\alias{pairwise,NumericMeasure,vector,matrix-method}
\alias{pairwise,Chebyshev,matrix,matrix-method}
\alias{pairwise,Chebyshev,matrix,NULL-method}
\alias{elementwise,Minkowski,matrix,matrix-method}
\alias{pairwise,Minkowski,matrix,matrix-method}
\alias{pairwise,Minkowski,matrix,NULL-method}
\alias{pairwise,InVocabulary,vector,vector-method}
\alias{pairwise,InVocabulary,vector,NULL-method}
\alias{pairwise,Lookup,vector,vector-method}
\alias{pairwise,Lookup,vector,NULL-method}
\alias{pairwise,MongeElkan,vector,vector-method}
\alias{pairwise,MongeElkan,vector,NULL-method}
\title{Pairwise Similarity/Distance Matrix}
\usage{
pairwise(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{Measure,ANY,missing}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{CppMeasure,vector,vector}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{CppMeasure,vector,`NULL`}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{StringMeasure,vector,vector}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{NumericMeasure,matrix,vector}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{NumericMeasure,vector,matrix}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{Chebyshev,matrix,matrix}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{Chebyshev,matrix,`NULL`}(measure, x, y, return_matrix = FALSE, ...)

\S4method{elementwise}{Minkowski,matrix,matrix}(measure, x, y, ...)

\S4method{pairwise}{Minkowski,matrix,matrix}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{Minkowski,matrix,`NULL`}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{InVocabulary,vector,vector}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{InVocabulary,vector,`NULL`}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{Lookup,vector,vector}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{Lookup,vector,`NULL`}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{MongeElkan,vector,vector}(measure, x, y, return_matrix = FALSE, ...)

\S4method{pairwise}{MongeElkan,vector,`NULL`}(measure, x, y, return_matrix = FALSE, ...)
}
\arguments{
\item{measure}{a measure used to compare the objects, which is a sub-class
of \code{\linkS4class{Measure}}.}

\item{x, y}{a collection of objects to compare, typically stored as entries
in an atomic vector, rows in a matrix, or entries in a list. The required
format depends on the type of \code{measure}. \code{y} may be omitted or set to
\code{NULL} to compare objects in \code{x}.}

\item{return_matrix}{a logical of length 1. If FALSE (default), the pairwise
similarities/distances will be returned as a \code{\linkS4class{PairwiseMatrix}}
which is more space-efficient for symmetric measures. If TRUE, a standard
\code{\link{matrix}} is returned instead.}

\item{...}{other parameters passed on to other methods.}
}
\value{
If both \code{x} and \code{y} are specified, every object in \code{x} is compared with
every object in \code{y} using the measure, and the resulting scores are returned
in a \verb{size(x) × size(y)} matrix.

If only \code{x} is specified, then the objects in \code{x} are compared with
themselves using the measure, and the resulting scores are returned in a
\verb{size(x) × size(y)} matrix.

By default, the matrix is represented as an instance of the
\code{\linkS4class{PairwiseMatrix}} class, which is more space-efficient for symmetric
measures when \code{y} is not specified. However, if \code{return_matrix = TRUE},
the matrix is returned as an ordinary \code{\link{matrix}} instead.
}
\description{
Computes pairwise similarities/distances between two collections of objects
(strings, vectors, etc.) using the provided measure.
}
\section{Methods (by class)}{
\itemize{
\item \code{measure = Measure,x = ANY,y = missing}: Compute a pairwise measure when \code{y}

\item \code{measure = CppMeasure,x = vector,y = vector}: Specialization for \code{\linkS4class{CppMeasure}} where \code{x} and
\code{y} are vectors of strings to compare.

\item \code{measure = CppMeasure,x = vector,y = NULL}: Specialization for \code{\linkS4class{CppMeasure}} where \code{x} is
a vector of strings to compare among themselves.

\item \code{measure = StringMeasure,x = vector,y = vector}: Specialization for \code{\link{StringMeasure}} where \code{x} and \code{y} are vectors of strings to compare

\item \code{measure = NumericMeasure,x = matrix,y = vector}: Specialization for \code{\link{NumericMeasure}} where \code{x} is a
matrix of rows (interpreted as vectors) to compare with a vector \code{y}.

\item \code{measure = NumericMeasure,x = vector,y = matrix}: Specialization for \code{\link{NumericMeasure}} where \code{x} is a
vector to compare with a matrix \code{y} of rows (interpreted as vectors).

\item \code{measure = Chebyshev,x = matrix,y = matrix}: Specialization for \code{\link{Chebyshev}} where \code{x} and \code{y}
matrices of rows (interpreted as vectors) to compare.

\item \code{measure = Chebyshev,x = matrix,y = NULL}: Specialization for \code{\link{Minkowski}} where \code{x} is a matrix
of rows (interpreted as vectors) to compare among themselves.

\item \code{measure = Minkowski,x = matrix,y = matrix}: Specialization for a \code{\link{Minkowski}} where \code{x} and \code{y}
matrices of rows (interpreted as vectors) to compare.

\item \code{measure = Minkowski,x = matrix,y = matrix}: Specialization for a \code{\link{Minkowski}} where \code{x} and \code{y}
matrices of rows (interpreted as vectors) to compare.

\item \code{measure = Minkowski,x = matrix,y = NULL}: Specialization for \code{\link{Minkowski}} where \code{x} is a matrix
of rows (interpreted as vectors) to compare among themselves.

\item \code{measure = InVocabulary,x = vector,y = vector}: Specialization for \code{\link{InVocabulary}} where \code{x} and \code{y}
are vectors of strings to compare.

\item \code{measure = InVocabulary,x = vector,y = NULL}: Specialization for \code{\link{InVocabulary}} where \code{x} is a
vector of strings to compare among themselves.

\item \code{measure = Lookup,x = vector,y = vector}: Specialization for a \code{\link{Lookup}} where \code{x} and \code{y} are
vectors of strings to compare

\item \code{measure = Lookup,x = vector,y = NULL}: Specialization for \code{\link{Lookup}} where \code{x} is a vector of
strings to compare among themselves

\item \code{measure = MongeElkan,x = vector,y = vector}: Specialization for \code{\link{MongeElkan}} where \code{x} and \code{y} are
vectors of strings to compare.

\item \code{measure = MongeElkan,x = vector,y = NULL}: Specialization for \code{\link{MongeElkan}} where \code{x} is a vector
of strings to compare among themselves.
}}

\examples{
## Computing the distances between a query point y (a 3D numeric vector) 
## and a set of reference points x
x <- rbind(c(1,0,1), c(0,0,0), c(-1,2,-1))
y <- c(10, 5, 10)
pairwise(Manhattan(), x, y)

## Computing the pairwise similarities among a set of strings
x <- c("Benjamin", "Ben", "Benny", "Bne", "Benedict", "Benson")
measure <- DamerauLevenshtein(similarity = TRUE, normalize = TRUE)
pairwise(measure, x, return_matrix = TRUE)  # return an ordinary matrix

}
